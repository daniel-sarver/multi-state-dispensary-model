"""
Feature Validator for Multi-State Dispensary Model

This module provides validation and auto-generation capabilities for the 44 model features.
It handles:
- Range validation using training data statistics
- Auto-generation of state interaction features (10 features)
- Auto-generation of state indicator features (is_FL, is_PA)
- Auto-generation of derived features (saturation, demographic interactions)
- Type validation and completeness checks

Usage:
    validator = FeatureValidator()

    # User provides base features + state
    base_features = {
        'sq_ft': 3500,
        'pop_5mi': 120000,
        'competitors_5mi': 5,
        'competition_weighted_20mi': 15.2,  # Pre-computed from distance matrix
        ...  # Other base features (23 total required)
    }

    # Validate and generate all 44 features
    complete_features = validator.prepare_features(base_features, state='FL')

    # Use with predictor
    from src.prediction.predictor import MultiStatePredictor
    predictor = MultiStatePredictor()
    prediction = predictor.predict(complete_features)
"""

import json
import os
from typing import Dict, List, Tuple, Any, Optional


class FeatureValidator:
    """
    Validates and generates complete feature sets for multi-state dispensary prediction.

    Attributes:
        feature_ranges: Min/max/mean/median values from training data
        required_base_features: Features user must provide
        auto_generated_features: Features system generates automatically
        all_feature_names: All 44 features required by model
    """

    # Features that must be provided by user
    REQUIRED_BASE_FEATURES = [
        # Dispensary characteristics
        'sq_ft',

        # Multi-radius populations
        'pop_1mi', 'pop_3mi', 'pop_5mi', 'pop_10mi', 'pop_20mi',

        # Competitor counts
        'competitors_1mi', 'competitors_3mi', 'competitors_5mi',
        'competitors_10mi', 'competitors_20mi',

        # Census demographics
        'total_population', 'median_age', 'median_household_income',
        'per_capita_income', 'total_pop_25_plus', 'bachelors_degree',
        'masters_degree', 'professional_degree', 'doctorate_degree',
        'population_density', 'tract_area_sqm',

        # Distance-weighted competition (requires pre-computation from distance matrix)
        'competition_weighted_20mi'
    ]

    # Features auto-generated by system
    AUTO_GENERATED_FEATURES = [
        # State indicators
        'is_FL', 'is_PA',

        # Market saturation (from pop + competitors)
        'saturation_1mi', 'saturation_3mi', 'saturation_5mi',
        'saturation_10mi', 'saturation_20mi',

        # Demographic interactions
        'pct_bachelor_plus', 'affluent_market_5mi', 'educated_urban_score',
        'age_adjusted_catchment_3mi',

        # State interactions
        'pop_5mi_FL', 'pop_5mi_PA', 'pop_20mi_FL', 'pop_20mi_PA',
        'competitors_5mi_FL', 'competitors_5mi_PA',
        'saturation_5mi_FL', 'saturation_5mi_PA',
        'median_household_income_FL', 'median_household_income_PA'
    ]

    # All 44 features in model order
    ALL_FEATURES = [
        'sq_ft', 'total_population', 'median_age', 'median_household_income',
        'per_capita_income', 'total_pop_25_plus', 'bachelors_degree', 'masters_degree',
        'professional_degree', 'doctorate_degree', 'pop_1mi', 'pop_3mi', 'pop_5mi',
        'pop_10mi', 'pop_20mi', 'pct_bachelor_plus', 'population_density',
        'tract_area_sqm', 'competitors_1mi', 'competitors_3mi', 'competitors_5mi',
        'competitors_10mi', 'competitors_20mi', 'competition_weighted_20mi',
        'saturation_1mi', 'saturation_3mi', 'saturation_5mi', 'saturation_10mi',
        'saturation_20mi', 'affluent_market_5mi', 'educated_urban_score',
        'age_adjusted_catchment_3mi', 'is_FL', 'is_PA', 'pop_5mi_FL', 'pop_5mi_PA',
        'pop_20mi_FL', 'pop_20mi_PA', 'competitors_5mi_FL', 'competitors_5mi_PA',
        'saturation_5mi_FL', 'saturation_5mi_PA', 'median_household_income_FL',
        'median_household_income_PA'
    ]

    def __init__(self, ranges_path: str = 'data/models/feature_ranges.json'):
        """
        Initialize validator with training data ranges.

        Args:
            ranges_path: Path to JSON file with feature min/max/mean/median values
        """
        self.feature_ranges = self._load_feature_ranges(ranges_path)

    def _load_feature_ranges(self, path: str) -> Dict[str, Dict[str, float]]:
        """Load feature ranges from JSON file."""
        if not os.path.exists(path):
            print(f"⚠️  Warning: Feature ranges file not found at {path}")
            print("    Range validation will be limited to basic checks")
            return {}

        with open(path, 'r') as f:
            ranges = json.load(f)

        print(f"✅ Loaded feature ranges for {len(ranges)} features")
        return ranges

    def prepare_features(self, base_features: Dict[str, Any], state: str) -> Dict[str, float]:
        """
        Main entry point: Validate base features and generate complete feature set.

        Args:
            base_features: User-provided features (23 required base features including
                          competition_weighted_20mi which must be pre-computed)
            state: 'FL' or 'PA'

        Returns:
            Complete dictionary with all 44 features

        Raises:
            ValueError: If validation fails or features are missing/invalid
        """
        features, _ = self.prepare_features_with_warnings(base_features, state)
        return features

    def prepare_features_with_warnings(
        self, base_features: Dict[str, Any], state: str
    ) -> Tuple[Dict[str, float], List[Dict[str, str]]]:
        """
        Validate base features and generate complete feature set with warnings.

        Args:
            base_features: User-provided features (23 required base features)
            state: 'FL' or 'PA'

        Returns:
            Tuple of (complete_features, warnings_list)
            - complete_features: Complete dictionary with all 44 features
            - warnings_list: List of warning dicts with 'type', 'feature', 'value', 'range', 'message'

        Raises:
            ValueError: If validation fails (missing features, negative values, etc.)
        """
        # Step 1: Validate state
        state = self._validate_state(state)

        # Step 2: Validate base features present
        self._validate_base_features_present(base_features)

        # Step 3: Validate types and ranges (now returns warnings)
        validated_base, warnings = self._validate_base_feature_values(base_features)

        # Step 4: Generate all derived features
        complete_features = self._generate_all_derived_features(validated_base, state)

        # Step 5: Final completeness check
        self._validate_complete_features(complete_features)

        return complete_features, warnings

    def _validate_state(self, state: str) -> str:
        """Validate and normalize state input."""
        if not isinstance(state, str):
            raise ValueError(f"State must be a string, got {type(state)}")

        state = state.upper().strip()

        if state not in ['FL', 'PA']:
            raise ValueError(f"State must be 'FL' or 'PA', got '{state}'")

        return state

    def _validate_base_features_present(self, features: Dict[str, Any]) -> None:
        """Check that all required base features are present."""
        missing = []
        for feat in self.REQUIRED_BASE_FEATURES:
            if feat not in features:
                missing.append(feat)

        if missing:
            raise ValueError(
                f"Missing {len(missing)} required base features:\n" +
                "\n".join(f"  - {feat}" for feat in sorted(missing))
            )

    def _validate_base_feature_values(self, features: Dict[str, Any]) -> Tuple[Dict[str, float], List[Dict[str, str]]]:
        """
        Validate types, ranges, and business logic for base features.

        Returns:
            Tuple of (validated_features, warnings_list)
            - validated_features: Dict[str, float]
            - warnings_list: List of warning dicts with structured info
        """
        validated = {}
        warnings_list = []
        errors = []

        for feat_name, value in features.items():
            # Skip if not a required base feature
            if feat_name not in self.REQUIRED_BASE_FEATURES:
                continue

            # Type validation
            try:
                value_float = float(value)
            except (TypeError, ValueError):
                errors.append(f"{feat_name}: Cannot convert to float (value: {value})")
                continue

            # Basic sanity checks
            if feat_name == 'sq_ft' and value_float <= 0:
                errors.append(f"{feat_name}: Must be positive (got {value_float})")
                continue

            if feat_name.startswith('pop_') and value_float < 0:
                errors.append(f"{feat_name}: Cannot be negative (got {value_float})")
                continue

            if feat_name.startswith('competitors_') and value_float < 0:
                errors.append(f"{feat_name}: Cannot be negative (got {value_float})")
                continue

            # Range validation against training data
            if feat_name in self.feature_ranges:
                ranges = self.feature_ranges[feat_name]
                min_val = ranges['min']
                max_val = ranges['max']

                # Warnings for extreme out-of-range values (changed from errors)
                if value_float < min_val * 0.5 or value_float > max_val * 2.0:
                    warnings_list.append({
                        'type': 'extreme',
                        'feature': feat_name,
                        'value': value_float,
                        'min': min_val,
                        'max': max_val,
                        'message': f"{feat_name}: Value {value_float:,.2f} is extreme. Training range: [{min_val:,.2f}, {max_val:,.2f}]"
                    })
                # Warnings for outside training range but not extreme
                elif value_float < min_val or value_float > max_val:
                    warnings_list.append({
                        'type': 'out_of_range',
                        'feature': feat_name,
                        'value': value_float,
                        'min': min_val,
                        'max': max_val,
                        'message': f"{feat_name}: Value {value_float:,.2f} outside training range [{min_val:,.2f}, {max_val:,.2f}]"
                    })

            validated[feat_name] = value_float

        # Raise if errors (hard errors only - not warnings)
        if errors:
            raise ValueError(
                f"Feature validation failed with {len(errors)} error(s):\n" +
                "\n".join(f"  - {e}" for e in errors)
            )

        return validated, warnings_list

    def _generate_all_derived_features(
        self, base_features: Dict[str, float], state: str
    ) -> Dict[str, float]:
        """
        Generate all derived features from base features.

        Returns:
            Complete feature dict with base + derived features
        """
        complete = base_features.copy()

        # 1. State indicators
        complete['is_FL'] = 1.0 if state == 'FL' else 0.0
        complete['is_PA'] = 1.0 if state == 'PA' else 0.0

        # 2. Market saturation (dispensaries per capita)
        for radius in ['1mi', '3mi', '5mi', '10mi', '20mi']:
            pop_key = f'pop_{radius}'
            comp_key = f'competitors_{radius}'
            sat_key = f'saturation_{radius}'

            if base_features[pop_key] > 0:
                complete[sat_key] = base_features[comp_key] / base_features[pop_key] * 100000
            else:
                complete[sat_key] = 0.0

        # 3. Demographic interactions
        # Percent with bachelor's or higher
        if base_features['total_pop_25_plus'] > 0:
            bachelor_plus = (
                base_features['bachelors_degree'] +
                base_features['masters_degree'] +
                base_features['professional_degree'] +
                base_features['doctorate_degree']
            )
            complete['pct_bachelor_plus'] = (bachelor_plus / base_features['total_pop_25_plus']) * 100
        else:
            complete['pct_bachelor_plus'] = 0.0

        # Affluent market (high income × large population)
        # Formula: pop_5mi × median_household_income / 1e6
        complete['affluent_market_5mi'] = (
            base_features['pop_5mi'] * base_features['median_household_income'] / 1e6
        )

        # Educated urban score (education × density)
        # Formula: pct_bachelor_plus × population_density
        complete['educated_urban_score'] = (
            complete['pct_bachelor_plus'] * base_features['population_density']
        )

        # Age-adjusted catchment
        # Formula: median_age × pop_3mi / 1000
        complete['age_adjusted_catchment_3mi'] = (
            base_features['median_age'] * base_features['pop_3mi'] / 1000
        )

        # 4. Distance-weighted competition
        # NOTE: This feature requires the full pairwise distance matrix from training.
        # The bucket-based approximation is inaccurate (~50% error).
        # For now, we require users to provide this pre-computed feature.
        # TODO: Implement full distance-based calculation or provide helper function.
        if 'competition_weighted_20mi' not in base_features:
            raise ValueError(
                "competition_weighted_20mi must be provided as a pre-computed feature. "
                "This feature requires the full pairwise distance matrix and cannot be "
                "accurately approximated from radius buckets alone."
            )
        complete['competition_weighted_20mi'] = base_features['competition_weighted_20mi']

        # 5. State interaction features
        # These multiply base features by state indicators
        complete['pop_5mi_FL'] = complete['pop_5mi'] * complete['is_FL']
        complete['pop_5mi_PA'] = complete['pop_5mi'] * complete['is_PA']
        complete['pop_20mi_FL'] = complete['pop_20mi'] * complete['is_FL']
        complete['pop_20mi_PA'] = complete['pop_20mi'] * complete['is_PA']
        complete['competitors_5mi_FL'] = complete['competitors_5mi'] * complete['is_FL']
        complete['competitors_5mi_PA'] = complete['competitors_5mi'] * complete['is_PA']
        complete['saturation_5mi_FL'] = complete['saturation_5mi'] * complete['is_FL']
        complete['saturation_5mi_PA'] = complete['saturation_5mi'] * complete['is_PA']
        complete['median_household_income_FL'] = complete['median_household_income'] * complete['is_FL']
        complete['median_household_income_PA'] = complete['median_household_income'] * complete['is_PA']

        return complete

    def _validate_complete_features(self, features: Dict[str, float]) -> None:
        """Final check that all 44 required features are present."""
        missing = []
        for feat in self.ALL_FEATURES:
            if feat not in features:
                missing.append(feat)

        if missing:
            raise ValueError(
                f"Missing {len(missing)} features after generation:\n" +
                "\n".join(f"  - {feat}" for feat in sorted(missing))
            )

        # Validate state indicators
        is_fl = features.get('is_FL', 0)
        is_pa = features.get('is_PA', 0)

        if is_fl not in [0.0, 1.0]:
            raise ValueError(f"is_FL must be 0 or 1, got {is_fl}")

        if is_pa not in [0.0, 1.0]:
            raise ValueError(f"is_PA must be 0 or 1, got {is_pa}")

        if is_fl == 1.0 and is_pa == 1.0:
            raise ValueError("Both is_FL and is_PA cannot be 1")

    def get_feature_ranges(self) -> Dict[str, Dict[str, float]]:
        """Return feature ranges from training data."""
        return self.feature_ranges.copy()

    def get_required_base_features(self) -> List[str]:
        """Return list of features user must provide."""
        return self.REQUIRED_BASE_FEATURES.copy()

    def get_auto_generated_features(self) -> List[str]:
        """Return list of features system generates."""
        return self.AUTO_GENERATED_FEATURES.copy()

    def get_feature_info(self, feature_name: str) -> Dict[str, Any]:
        """
        Get information about a specific feature.

        Returns dict with:
            - name: Feature name
            - required: Whether user must provide it
            - auto_generated: Whether system generates it
            - ranges: Min/max/mean/median if available
        """
        info = {
            'name': feature_name,
            'required': feature_name in self.REQUIRED_BASE_FEATURES,
            'auto_generated': feature_name in self.AUTO_GENERATED_FEATURES,
            'ranges': self.feature_ranges.get(feature_name, None)
        }
        return info

    def validate_batch(
        self, features_df, state_column: str = 'state'
    ) -> Tuple[List[Dict[str, float]], List[Tuple[int, str]]]:
        """
        Validate and prepare features for batch prediction.

        Args:
            features_df: DataFrame with base features and state column
            state_column: Name of column containing state ('FL' or 'PA')

        Returns:
            Tuple of:
                - List of validated feature dicts (one per row)
                - List of (row_index, error_message) for failed rows
        """
        validated_rows = []
        errors = []

        for idx, row in features_df.iterrows():
            try:
                state = row[state_column]
                base_features = {
                    col: row[col] for col in self.REQUIRED_BASE_FEATURES
                    if col in row.index
                }
                complete_features = self.prepare_features(base_features, state)
                validated_rows.append(complete_features)
            except Exception as e:
                errors.append((idx, str(e)))

        return validated_rows, errors


# Example usage
if __name__ == "__main__":
    print("=" * 80)
    print("Feature Validator Test")
    print("=" * 80)

    # Initialize validator
    validator = FeatureValidator()

    print(f"\n✅ Validator initialized")
    print(f"   Required base features: {len(validator.REQUIRED_BASE_FEATURES)}")
    print(f"   Auto-generated features: {len(validator.AUTO_GENERATED_FEATURES)}")
    print(f"   Total features: {len(validator.ALL_FEATURES)}")

    # Example: Create base features for a Florida site
    print("\n" + "=" * 80)
    print("Example 1: Florida Dispensary")
    print("=" * 80)

    base_features = {
        # Dispensary
        'sq_ft': 4587,

        # Multi-radius populations
        'pop_1mi': 5949.93,
        'pop_3mi': 52820.65,
        'pop_5mi': 71105.91,
        'pop_10mi': 176027.83,
        'pop_20mi': 563095.62,

        # Competitors
        'competitors_1mi': 0,
        'competitors_3mi': 2,
        'competitors_5mi': 3,
        'competitors_10mi': 5,
        'competitors_20mi': 13,

        # Distance-weighted competition (pre-computed)
        'competition_weighted_20mi': 1.78,

        # Census demographics
        'total_population': 4062,
        'median_age': 29.1,
        'median_household_income': 76458,
        'per_capita_income': 37439,
        'total_pop_25_plus': 2369,
        'bachelors_degree': 424,
        'masters_degree': 125,
        'professional_degree': 0,
        'doctorate_degree': 18,
        'population_density': 890.55,
        'tract_area_sqm': 4561619.35
    }

    try:
        complete_features = validator.prepare_features(base_features, state='FL')

        print(f"\n✅ Validation successful!")
        print(f"   Base features provided: {len(base_features)}")
        print(f"   Complete features generated: {len(complete_features)}")

        print("\n📊 Generated Features Sample:")
        print(f"   is_FL: {complete_features['is_FL']}")
        print(f"   is_PA: {complete_features['is_PA']}")
        print(f"   saturation_5mi: {complete_features['saturation_5mi']:.2f}")
        print(f"   pct_bachelor_plus: {complete_features['pct_bachelor_plus']:.2f}%")
        print(f"   pop_5mi_FL: {complete_features['pop_5mi_FL']:,.0f}")
        print(f"   pop_5mi_PA: {complete_features['pop_5mi_PA']:,.0f}")
        print(f"   competition_weighted_20mi: {complete_features['competition_weighted_20mi']:.2f}")

        # Test with predictor
        print("\n" + "=" * 80)
        print("Testing with Predictor")
        print("=" * 80)

        from predictor import MultiStatePredictor
        predictor = MultiStatePredictor()

        prediction = predictor.predict(complete_features)
        print(f"\n✅ Prediction: {prediction:,.0f} visits/month")

        result = predictor.predict_with_confidence(complete_features)
        print(f"   95% CI: {result['ci_lower']:,.0f} - {result['ci_upper']:,.0f}")
        print(f"   State: {result['state']}")
        print(f"   RMSE used: {result['rmse_used']:,.0f}")

    except ValueError as e:
        print(f"\n❌ Validation failed: {e}")

    print("\n" + "=" * 80)
    print("Feature Validator Ready!")
    print("=" * 80)
